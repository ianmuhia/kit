package app

import (
	"context"
	"errors"
	"testing"

	"{{.ModulePath}}/internal/{{.DomainLower}}/domain"
)

// Mock{{.DomainTitle}}Repository is a mock implementation of domain.Repository
type Mock{{.DomainTitle}}Repository struct {
	CreateFunc  func(ctx context.Context, entity *domain.{{.DomainTitle}}) error
	UpdateFunc  func(ctx context.Context, entity *domain.{{.DomainTitle}}) error
	DeleteFunc  func(ctx context.Context, id int) error
	GetByIDFunc func(ctx context.Context, id int) (*domain.{{.DomainTitle}}, error)
	ListFunc    func(ctx context.Context, filters domain.ListFilters) ([]*domain.{{.DomainTitle}}, error)
	CountFunc   func(ctx context.Context, filters domain.ListFilters) (int, error)
}

func (m *Mock{{.DomainTitle}}Repository) Create(ctx context.Context, entity *domain.{{.DomainTitle}}) error {
	if m.CreateFunc != nil {
		return m.CreateFunc(ctx, entity)
	}
	return nil
}

func (m *Mock{{.DomainTitle}}Repository) Update(ctx context.Context, entity *domain.{{.DomainTitle}}) error {
	if m.UpdateFunc != nil {
		return m.UpdateFunc(ctx, entity)
	}
	return nil
}

func (m *Mock{{.DomainTitle}}Repository) Delete(ctx context.Context, id int) error {
	if m.DeleteFunc != nil {
		return m.DeleteFunc(ctx, id)
	}
	return nil
}

func (m *Mock{{.DomainTitle}}Repository) GetByID(ctx context.Context, id int) (*domain.{{.DomainTitle}}, error) {
	if m.GetByIDFunc != nil {
		return m.GetByIDFunc(ctx, id)
	}
	return nil, nil
}

func (m *Mock{{.DomainTitle}}Repository) List(ctx context.Context, filters domain.ListFilters) ([]*domain.{{.DomainTitle}}, error) {
	if m.ListFunc != nil {
		return m.ListFunc(ctx, filters)
	}
	return nil, nil
}

func (m *Mock{{.DomainTitle}}Repository) Count(ctx context.Context, filters domain.ListFilters) (int, error) {
	if m.CountFunc != nil {
		return m.CountFunc(ctx, filters)
	}
	return 0, nil
}

func TestService_Create{{.DomainTitle}}(t *testing.T) {
	tests := []struct {
		name    string
		cmd     Create{{.DomainTitle}}Command
		setup   func(*Mock{{.DomainTitle}}Repository)
		wantErr bool
		errMsg  string
	}{
		{
			name: "successful creation",
			cmd: Create{{.DomainTitle}}Command{
				Name:        "Test {{.DomainTitle}}",
				Description: "Test description",
				Active:      true,
				CreatedBy:   1,
			},
			setup: func(repo *Mock{{.DomainTitle}}Repository) {
				repo.CreateFunc = func(ctx context.Context, entity *domain.{{.DomainTitle}}) error {
					entity.ID = 123
					return nil
				}
			},
			wantErr: false,
		},
		{
			name: "validation error - empty name",
			cmd: Create{{.DomainTitle}}Command{
				Name:        "",
				Description: "Test description",
				Active:      true,
				CreatedBy:   1,
			},
			setup:   func(repo *Mock{{.DomainTitle}}Repository) {},
			wantErr: true,
			errMsg:  "{{.DomainLower}} name is required",
		},
		{
			name: "repository error",
			cmd: Create{{.DomainTitle}}Command{
				Name:        "Test {{.DomainTitle}}",
				Description: "Test description",
				Active:      true,
				CreatedBy:   1,
			},
			setup: func(repo *Mock{{.DomainTitle}}Repository) {
				repo.CreateFunc = func(ctx context.Context, entity *domain.{{.DomainTitle}}) error {
					return errors.New("database error")
				}
			},
			wantErr: true,
			errMsg:  "database error",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			repo := &Mock{{.DomainTitle}}Repository{}
			tt.setup(repo)

			service := NewService(repo)
			ctx := context.Background()

			result, err := service.Create{{.DomainTitle}}(ctx, tt.cmd)

			if tt.wantErr {
				if err == nil {
					t.Errorf("expected error containing %q, got nil", tt.errMsg)
				} else if tt.errMsg != "" && !contains(err.Error(), tt.errMsg) {
					t.Errorf("expected error containing %q, got %q", tt.errMsg, err.Error())
				}
			} else {
				if err != nil {
					t.Errorf("unexpected error: %v", err)
				}
				if result == nil {
					t.Error("expected result, got nil")
				}
			}
		})
	}
}

func TestService_Get{{.DomainTitle}}(t *testing.T) {
	tests := []struct {
		name    string
		id      int
		setup   func(*Mock{{.DomainTitle}}Repository)
		wantErr bool
		errMsg  string
	}{
		{
			name: "successful retrieval",
			id:   1,
			setup: func(repo *Mock{{.DomainTitle}}Repository) {
				repo.GetByIDFunc = func(ctx context.Context, id int) (*domain.{{.DomainTitle}}, error) {
					return &domain.{{.DomainTitle}}{
						ID:     id,
						Name:   "Test {{.DomainTitle}}",
						Active: true,
					}, nil
				}
			},
			wantErr: false,
		},
		{
			name: "not found",
			id:   999,
			setup: func(repo *Mock{{.DomainTitle}}Repository) {
				repo.GetByIDFunc = func(ctx context.Context, id int) (*domain.{{.DomainTitle}}, error) {
					return nil, domain.Err{{.DomainTitle}}NotFound
				}
			},
			wantErr: true,
			errMsg:  "{{.DomainLower}} not found",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			repo := &Mock{{.DomainTitle}}Repository{}
			tt.setup(repo)

			service := NewService(repo)
			ctx := context.Background()

			result, err := service.Get{{.DomainTitle}}(ctx, tt.id)

			if tt.wantErr {
				if err == nil {
					t.Errorf("expected error containing %q, got nil", tt.errMsg)
				} else if tt.errMsg != "" && !contains(err.Error(), tt.errMsg) {
					t.Errorf("expected error containing %q, got %q", tt.errMsg, err.Error())
				}
			} else {
				if err != nil {
					t.Errorf("unexpected error: %v", err)
				}
				if result == nil {
					t.Error("expected result, got nil")
				}
			}
		})
	}
}

func TestService_Update{{.DomainTitle}}(t *testing.T) {
	tests := []struct {
		name    string
		id      int
		cmd     Update{{.DomainTitle}}Command
		setup   func(*Mock{{.DomainTitle}}Repository)
		wantErr bool
		errMsg  string
	}{
		{
			name: "successful update",
			id:   1,
			cmd: Update{{.DomainTitle}}Command{
				Name:        "Updated {{.DomainTitle}}",
				Description: "Updated description",
				UpdatedBy:   1,
			},
			setup: func(repo *Mock{{.DomainTitle}}Repository) {
				repo.GetByIDFunc = func(ctx context.Context, id int) (*domain.{{.DomainTitle}}, error) {
					return &domain.{{.DomainTitle}}{
						ID:     id,
						Name:   "Old Name",
						Active: true,
					}, nil
				}
				repo.UpdateFunc = func(ctx context.Context, entity *domain.{{.DomainTitle}}) error {
					return nil
				}
			},
			wantErr: false,
		},
		{
			name: "not found",
			id:   999,
			cmd: Update{{.DomainTitle}}Command{
				Name:        "Updated {{.DomainTitle}}",
				Description: "Updated description",
				UpdatedBy:   1,
			},
			setup: func(repo *Mock{{.DomainTitle}}Repository) {
				repo.GetByIDFunc = func(ctx context.Context, id int) (*domain.{{.DomainTitle}}, error) {
					return nil, domain.Err{{.DomainTitle}}NotFound
				}
			},
			wantErr: true,
			errMsg:  "{{.DomainLower}} not found",
		},
		{
			name: "cannot modify inactive {{.DomainLower}}",
			id:   1,
			cmd: Update{{.DomainTitle}}Command{
				Name:        "Updated {{.DomainTitle}}",
				Description: "Updated description",
				UpdatedBy:   1,
			},
			setup: func(repo *Mock{{.DomainTitle}}Repository) {
				repo.GetByIDFunc = func(ctx context.Context, id int) (*domain.{{.DomainTitle}}, error) {
					return &domain.{{.DomainTitle}}{
						ID:     id,
						Name:   "Test {{.DomainTitle}}",
						Active: false,
					}, nil
				}
			},
			wantErr: true,
			errMsg:  "{{.DomainLower}} is not active",
		},
		{
			name: "validation error - empty name",
			id:   1,
			cmd: Update{{.DomainTitle}}Command{
				Name:        "",
				Description: "Updated description",
				UpdatedBy:   1,
			},
			setup: func(repo *Mock{{.DomainTitle}}Repository) {
				repo.GetByIDFunc = func(ctx context.Context, id int) (*domain.{{.DomainTitle}}, error) {
					return &domain.{{.DomainTitle}}{
						ID:     id,
						Name:   "Old Name",
						Active: true,
					}, nil
				}
			},
			wantErr: true,
			errMsg:  "{{.DomainLower}} name is required",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			repo := &Mock{{.DomainTitle}}Repository{}
			tt.setup(repo)

			service := NewService(repo)
			ctx := context.Background()

			result, err := service.Update{{.DomainTitle}}(ctx, tt.id, tt.cmd)

			if tt.wantErr {
				if err == nil {
					t.Errorf("expected error containing %q, got nil", tt.errMsg)
				} else if tt.errMsg != "" && !contains(err.Error(), tt.errMsg) {
					t.Errorf("expected error containing %q, got %q", tt.errMsg, err.Error())
				}
			} else {
				if err != nil {
					t.Errorf("unexpected error: %v", err)
				}
				if result == nil {
					t.Error("expected result, got nil")
				}
			}
		})
	}
}

func TestService_Delete{{.DomainTitle}}(t *testing.T) {
	tests := []struct {
		name    string
		id      int
		setup   func(*Mock{{.DomainTitle}}Repository)
		wantErr bool
		errMsg  string
	}{
		{
			name: "successful deletion",
			id:   1,
			setup: func(repo *Mock{{.DomainTitle}}Repository) {
				repo.GetByIDFunc = func(ctx context.Context, id int) (*domain.{{.DomainTitle}}, error) {
					return &domain.{{.DomainTitle}}{
						ID:     id,
						Name:   "Test {{.DomainTitle}}",
						Active: true,
					}, nil
				}
				repo.DeleteFunc = func(ctx context.Context, id int) error {
					return nil
				}
			},
			wantErr: false,
		},
		{
			name: "not found",
			id:   999,
			setup: func(repo *Mock{{.DomainTitle}}Repository) {
				repo.GetByIDFunc = func(ctx context.Context, id int) (*domain.{{.DomainTitle}}, error) {
					return nil, domain.Err{{.DomainTitle}}NotFound
				}
			},
			wantErr: true,
			errMsg:  "{{.DomainLower}} not found",
		},
		{
			name: "cannot delete inactive {{.DomainLower}}",
			id:   1,
			setup: func(repo *Mock{{.DomainTitle}}Repository) {
				repo.GetByIDFunc = func(ctx context.Context, id int) (*domain.{{.DomainTitle}}, error) {
					return &domain.{{.DomainTitle}}{
						ID:     id,
						Name:   "Test {{.DomainTitle}}",
						Active: false,
					}, nil
				}
			},
			wantErr: true,
			errMsg:  "{{.DomainLower}} is not active",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			repo := &Mock{{.DomainTitle}}Repository{}
			tt.setup(repo)

			service := NewService(repo)
			ctx := context.Background()

			err := service.Delete{{.DomainTitle}}(ctx, tt.id)

			if tt.wantErr {
				if err == nil {
					t.Errorf("expected error containing %q, got nil", tt.errMsg)
				} else if tt.errMsg != "" && !contains(err.Error(), tt.errMsg) {
					t.Errorf("expected error containing %q, got %q", tt.errMsg, err.Error())
				}
			} else {
				if err != nil {
					t.Errorf("unexpected error: %v", err)
				}
			}
		})
	}
}

func TestService_List{{.DomainTitle}}s(t *testing.T) {
	tests := []struct {
		name       string
		filters    domain.ListFilters
		setup      func(*Mock{{.DomainTitle}}Repository)
		wantCount  int
		wantTotal  int
		wantErr    bool
	}{
		{
			name: "successful list",
			filters: domain.ListFilters{
				Page:     1,
				PageSize: 10,
			},
			setup: func(repo *Mock{{.DomainTitle}}Repository) {
				repo.ListFunc = func(ctx context.Context, filters domain.ListFilters) ([]*domain.{{.DomainTitle}}, error) {
					return []*domain.{{.DomainTitle}}{
						{ID: 1, Name: "{{.DomainTitle}} 1", Active: true},
						{ID: 2, Name: "{{.DomainTitle}} 2", Active: true},
					}, nil
				}
				repo.CountFunc = func(ctx context.Context, filters domain.ListFilters) (int, error) {
					return 2, nil
				}
			},
			wantCount: 2,
			wantTotal: 2,
			wantErr:   false,
		},
		{
			name: "empty list",
			filters: domain.ListFilters{
				Page:     1,
				PageSize: 10,
			},
			setup: func(repo *Mock{{.DomainTitle}}Repository) {
				repo.ListFunc = func(ctx context.Context, filters domain.ListFilters) ([]*domain.{{.DomainTitle}}, error) {
					return []*domain.{{.DomainTitle}}{}, nil
				}
				repo.CountFunc = func(ctx context.Context, filters domain.ListFilters) (int, error) {
					return 0, nil
				}
			},
			wantCount: 0,
			wantTotal: 0,
			wantErr:   false,
		},
		{
			name: "repository error",
			filters: domain.ListFilters{
				Page:     1,
				PageSize: 10,
			},
			setup: func(repo *Mock{{.DomainTitle}}Repository) {
				repo.ListFunc = func(ctx context.Context, filters domain.ListFilters) ([]*domain.{{.DomainTitle}}, error) {
					return nil, errors.New("database error")
				}
			},
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			repo := &Mock{{.DomainTitle}}Repository{}
			tt.setup(repo)

			service := NewService(repo)
			ctx := context.Background()

			items, total, err := service.List{{.DomainTitle}}s(ctx, tt.filters)

			if tt.wantErr {
				if err == nil {
					t.Error("expected error, got nil")
				}
			} else {
				if err != nil {
					t.Errorf("unexpected error: %v", err)
				}
				if len(items) != tt.wantCount {
					t.Errorf("expected %d items, got %d", tt.wantCount, len(items))
				}
				if total != tt.wantTotal {
					t.Errorf("expected total %d, got %d", tt.wantTotal, total)
				}
			}
		})
	}
}

// Helper function to check if a string contains a substring
func contains(s, substr string) bool {
	return len(s) >= len(substr) && (s == substr || len(substr) == 0 || 
		(len(s) > 0 && len(substr) > 0 && strings.Contains(s, substr)))
}
