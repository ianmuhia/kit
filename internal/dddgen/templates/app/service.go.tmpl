package app

import (
	"context"
	"time"

	{{.DomainLower}} "{{.ModulePath}}/internal/{{.DomainLower}}"
)

// {{.DomainTitle}}Publisher defines the interface for publishing {{.DomainLower}} events
type {{.DomainTitle}}Publisher interface {
	Publish{{.DomainTitle}}Created(ctx context.Context, event {{.DomainLower}}.{{.DomainTitle}}CreatedEvent) error
	Publish{{.DomainTitle}}Updated(ctx context.Context, event {{.DomainLower}}.{{.DomainTitle}}UpdatedEvent) error
	Publish{{.DomainTitle}}Deleted(ctx context.Context, event {{.DomainLower}}.{{.DomainTitle}}DeletedEvent) error
}

// Service orchestrates {{.DomainLower}} operations (no business logic here)
type Service struct {
	repo      {{.DomainLower}}.Repository
	publisher {{.DomainTitle}}Publisher
}

// NewService creates a new {{.DomainLower}} service
func NewService(repo {{.DomainLower}}.Repository, publisher {{.DomainTitle}}Publisher) *Service {
	return &Service{
		repo:      repo,
		publisher: publisher,
	}
}

// Create{{.DomainTitle}}Command represents create command
type Create{{.DomainTitle}}Command struct {
	Name        string
	Description string
	Active      bool
	CreatedBy   int
}

// Update{{.DomainTitle}}Command represents update command
type Update{{.DomainTitle}}Command struct {
	Name        string
	Description string
	UpdatedBy   int
}

// Create{{.DomainTitle}} creates a new {{.DomainLower}}
func (s *Service) Create{{.DomainTitle}}(ctx context.Context, cmd Create{{.DomainTitle}}Command) (*{{.DomainLower}}.{{.DomainTitle}}, error) {
	entity := &{{.DomainLower}}.{{.DomainTitle}}{
		Name:        cmd.Name,
		Description: cmd.Description,
		Active:      cmd.Active,
		CreatedBy:   cmd.CreatedBy,
	}

	// Domain validates itself
	if err := entity.Validate(); err != nil {
		return nil, err
	}

	if err := s.repo.Create(ctx, entity); err != nil {
		return nil, err
	}

	// Publish created event
	if s.publisher != nil {
		event := {{.DomainLower}}.{{.DomainTitle}}CreatedEvent{
			{{.DomainTitle}}ID: entity.ID,
			Name:               entity.Name,
			CreatedBy:          entity.CreatedBy,
			CreatedAt:          time.Now(),
		}
		if err := s.publisher.Publish{{.DomainTitle}}Created(ctx, event); err != nil {
			// Log error but don't fail the operation
			// In production, consider using a proper logger
			_ = err
		}
	}

	return entity, nil
}

// Get{{.DomainTitle}} retrieves a {{.DomainLower}} by ID
func (s *Service) Get{{.DomainTitle}}(ctx context.Context, id int) (*{{.DomainLower}}.{{.DomainTitle}}, error) {
	return s.repo.GetByID(ctx, id)
}

// Update{{.DomainTitle}} updates a {{.DomainLower}}
func (s *Service) Update{{.DomainTitle}}(ctx context.Context, id int, cmd Update{{.DomainTitle}}Command) (*{{.DomainLower}}.{{.DomainTitle}}, error) {
	entity, err := s.repo.GetByID(ctx, id)
	if err != nil {
		return nil, err
	}

	// Check business rules
	if err := entity.CanBeModified(); err != nil {
		return nil, err
	}

	// Update fields
	entity.Name = cmd.Name
	entity.Description = cmd.Description
	entity.UpdatedBy = cmd.UpdatedBy

	// Domain validates itself
	if err := entity.Validate(); err != nil {
		return nil, err
	}

	if err := s.repo.Update(ctx, entity); err != nil {
		return nil, err
	}

	// Publish updated event
	if s.publisher != nil {
		event := {{.DomainLower}}.{{.DomainTitle}}UpdatedEvent{
			{{.DomainTitle}}ID: entity.ID,
			UpdatedBy:          entity.UpdatedBy,
			UpdatedAt:          time.Now(),
		}
		if err := s.publisher.Publish{{.DomainTitle}}Updated(ctx, event); err != nil {
			// Log error but don't fail the operation
			_ = err
		}
	}

	return entity, nil
}

// Delete{{.DomainTitle}} deletes a {{.DomainLower}}
func (s *Service) Delete{{.DomainTitle}}(ctx context.Context, id int, deletedBy int) error {
	entity, err := s.repo.GetByID(ctx, id)
	if err != nil {
		return err
	}

	// Check business rules
	if err := entity.CanBeModified(); err != nil {
		return err
	}

	if err := s.repo.Delete(ctx, id); err != nil {
		return err
	}

	// Publish deleted event
	if s.publisher != nil {
		event := {{.DomainLower}}.{{.DomainTitle}}DeletedEvent{
			{{.DomainTitle}}ID: id,
			DeletedBy:          deletedBy,
			DeletedAt:          time.Now(),
		}
		if err := s.publisher.Publish{{.DomainTitle}}Deleted(ctx, event); err != nil {
			// Log error but don't fail the operation
			_ = err
		}
	}

	return nil
}

// List{{.DomainTitle}}s lists {{.DomainLower}}s with pagination
func (s *Service) List{{.DomainTitle}}s(ctx context.Context, filters {{.DomainLower}}.ListFilters) ([]*{{.DomainLower}}.{{.DomainTitle}}, int, error) {
	entities, err := s.repo.List(ctx, filters)
	if err != nil {
		return nil, 0, err
	}

	count, err := s.repo.Count(ctx, filters)
	if err != nil {
		return nil, 0, err
	}

	return entities, count, nil
}

// NoOp{{.DomainTitle}}Publisher is a no-op implementation of {{.DomainTitle}}Publisher
// Use this when messaging is not enabled
type NoOp{{.DomainTitle}}Publisher struct{}

func (p *NoOp{{.DomainTitle}}Publisher) Publish{{.DomainTitle}}Created(ctx context.Context, event {{.DomainLower}}.{{.DomainTitle}}CreatedEvent) error {
	return nil
}

func (p *NoOp{{.DomainTitle}}Publisher) Publish{{.DomainTitle}}Updated(ctx context.Context, event {{.DomainLower}}.{{.DomainTitle}}UpdatedEvent) error {
	return nil
}

func (p *NoOp{{.DomainTitle}}Publisher) Publish{{.DomainTitle}}Deleted(ctx context.Context, event {{.DomainLower}}.{{.DomainTitle}}DeletedEvent) error {
	return nil
}
