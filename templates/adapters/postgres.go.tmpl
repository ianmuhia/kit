package adapters

import (
	"context"
	"database/sql"
	"errors"
	"fmt"

	{{.DomainLower}} "ibnb/internal/{{.DomainLower}}"

	"github.com/jackc/pgx/v5/pgxpool"
)

// {{.DomainTitle}}PostgresRepository implements domain.Repository using PostgreSQL
type {{.DomainTitle}}PostgresRepository struct {
	db *pgxpool.Pool
}

// New{{.DomainTitle}}PostgresRepository creates a new PostgreSQL repository
func New{{.DomainTitle}}PostgresRepository(db *pgxpool.Pool) *{{.DomainTitle}}PostgresRepository {
	return &{{.DomainTitle}}PostgresRepository{
		db: db,
	}
}

// Create creates a new {{.DomainLower}}
func (r *{{.DomainTitle}}PostgresRepository) Create(ctx context.Context, entity *{{.DomainLower}}.{{.DomainTitle}}) error {
	query := `
		INSERT INTO {{.DomainLower}}s (name, description, active, created_by, updated_by)
		VALUES ($1, $2, $3, $4, $5)
		RETURNING id, created_at, updated_at
	`

	err := r.db.QueryRow(ctx, query,
		entity.Name,
		entity.Description,
		entity.Active,
		entity.CreatedBy,
		entity.UpdatedBy,
	).Scan(&entity.ID, &entity.CreatedAt, &entity.UpdatedAt)

	if err != nil {
		return fmt.Errorf("failed to create {{.DomainLower}}: %w", err)
	}

	return nil
}

// Update updates an existing {{.DomainLower}}
func (r *{{.DomainTitle}}PostgresRepository) Update(ctx context.Context, entity *{{.DomainLower}}.{{.DomainTitle}}) error {
	query := `
		UPDATE {{.DomainLower}}s
		SET name = $1, description = $2, active = $3, updated_by = $4, updated_at = NOW()
		WHERE id = $5
		RETURNING updated_at
	`

	err := r.db.QueryRow(ctx, query,
		entity.Name,
		entity.Description,
		entity.Active,
		entity.UpdatedBy,
		entity.ID,
	).Scan(&entity.UpdatedAt)

	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return domain.Err{{.DomainTitle}}NotFound
		}
		return fmt.Errorf("failed to update {{.DomainLower}}: %w", err)
	}

	return nil
}

// Delete deletes a {{.DomainLower}}
func (r *{{.DomainTitle}}PostgresRepository) Delete(ctx context.Context, id int) error {
	query := `DELETE FROM {{.DomainLower}}s WHERE id = $1`

	result, err := r.db.Exec(ctx, query, id)
	if err != nil {
		return fmt.Errorf("failed to delete {{.DomainLower}}: %w", err)
	}

	if result.RowsAffected() == 0 {
		return {{.DomainLower}}.Err{{.DomainTitle}}NotFound
	}

	return nil
}

// GetByID retrieves a {{.DomainLower}} by ID
func (r *{{.DomainTitle}}PostgresRepository) GetByID(ctx context.Context, id int) (*{{.DomainLower}}.{{.DomainTitle}}, error) {
	query := `
		SELECT id, name, description, active, created_at, updated_at, created_by, updated_by
		FROM {{.DomainLower}}s
		WHERE id = $1
	`

	entity := &{{.DomainLower}}.{{.DomainTitle}}{}
	err := r.db.QueryRow(ctx, query, id).Scan(
		&entity.ID,
		&entity.Name,
		&entity.Description,
		&entity.Active,
		&entity.CreatedAt,
		&entity.UpdatedAt,
		&entity.CreatedBy,
		&entity.UpdatedBy,
	)

	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, {{.DomainLower}}.Err{{.DomainTitle}}NotFound
		}
		return nil, fmt.Errorf("failed to get {{.DomainLower}}: %w", err)
	}

	return entity, nil
}

// List retrieves {{.DomainLower}}s with filters
func (r *{{.DomainTitle}}PostgresRepository) List(ctx context.Context, filters {{.DomainLower}}.ListFilters) ([]*{{.DomainLower}}.{{.DomainTitle}}, error) {
	query := `
		SELECT id, name, description, active, created_at, updated_at, created_by, updated_by
		FROM {{.DomainLower}}s
		WHERE 1=1
	`
	args := []interface{}{}
	argCount := 1

	if filters.Active != nil {
		query += fmt.Sprintf(" AND active = $%d", argCount)
		args = append(args, *filters.Active)
		argCount++
	}

	if filters.Search != "" {
		query += fmt.Sprintf(" AND (name ILIKE $%d OR description ILIKE $%d)", argCount, argCount)
		args = append(args, "%"+filters.Search+"%")
		argCount++
	}

	query += " ORDER BY created_at DESC"

	if filters.PageSize > 0 {
		offset := (filters.Page - 1) * filters.PageSize
		query += fmt.Sprintf(" LIMIT $%d OFFSET $%d", argCount, argCount+1)
		args = append(args, filters.PageSize, offset)
	}

	rows, err := r.db.Query(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to list {{.DomainLower}}s: %w", err)
	}
	defer rows.Close()

	var entities []*{{.DomainLower}}.{{.DomainTitle}}
	for rows.Next() {
		entity := &{{.DomainLower}}.{{.DomainTitle}}{}
		err := rows.Scan(
			&entity.ID,
			&entity.Name,
			&entity.Description,
			&entity.Active,
			&entity.CreatedAt,
			&entity.UpdatedAt,
			&entity.CreatedBy,
			&entity.UpdatedBy,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan {{.DomainLower}}: %w", err)
		}
		entities = append(entities, entity)
	}

	return entities, nil
}

// Count counts {{.DomainLower}}s matching filters
func (r *{{.DomainTitle}}PostgresRepository) Count(ctx context.Context, filters {{.DomainLower}}.ListFilters) (int, error) {
	query := `SELECT COUNT(*) FROM {{.DomainLower}}s WHERE 1=1`
	args := []interface{}{}
	argCount := 1

	if filters.Active != nil {
		query += fmt.Sprintf(" AND active = $%d", argCount)
		args = append(args, *filters.Active)
		argCount++
	}

	if filters.Search != "" {
		query += fmt.Sprintf(" AND (name ILIKE $%d OR description ILIKE $%d)", argCount, argCount)
		args = append(args, "%"+filters.Search+"%")
	}

	var count int
	err := r.db.QueryRow(ctx, query, args...).Scan(&count)
	if err != nil {
		return 0, fmt.Errorf("failed to count {{.DomainLower}}s: %w", err)
	}

	return count, nil
}
