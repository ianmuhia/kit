package app

import (
	"context"
	"fmt"
	"time"

	"ibnb/internal/{{.DomainLower}}/domain"
	"ibnb/pkg/auth"
	"ibnb/pkg/featureflags"
)

// ServiceDecorator wraps the service with cross-cutting concerns
type ServiceDecorator struct {
	base              *Service
	permissionChecker PermissionChecker
	auditLogger       AuditLogger
	featureFlags      featureflags.Client
	cache             CacheStore
	metrics           MetricsCollector
}

// PermissionChecker checks if user has permission to perform action
type PermissionChecker interface {
	CheckPermission(ctx context.Context, userID int, resource string, action string) error
}

// AuditLogger logs all changes for compliance
type AuditLogger interface {
	LogCreate(ctx context.Context, userID int, resource string, resourceID int, data interface{})
	LogUpdate(ctx context.Context, userID int, resource string, resourceID int, before, after interface{})
	LogDelete(ctx context.Context, userID int, resource string, resourceID int)
	LogAccess(ctx context.Context, userID int, resource string, resourceID int)
}

// CacheStore handles caching operations
type CacheStore interface {
	Get(ctx context.Context, key string, dest interface{}) error
	Set(ctx context.Context, key string, value interface{}, ttl time.Duration) error
	Delete(ctx context.Context, key string) error
	DeleteByPrefix(ctx context.Context, prefix string) error
}

// MetricsCollector collects metrics for monitoring
type MetricsCollector interface {
	IncrementCounter(metric string, labels map[string]string)
	RecordDuration(metric string, duration time.Duration, labels map[string]string)
	RecordGauge(metric string, value float64, labels map[string]string)
}

// NewServiceDecorator creates a decorated service with all cross-cutting concerns
func NewServiceDecorator(
	base *Service,
	permissionChecker PermissionChecker,
	auditLogger AuditLogger,
	featureFlags featureflags.Client,
	cache CacheStore,
	metrics MetricsCollector,
) *ServiceDecorator {
	return &ServiceDecorator{
		base:              base,
		permissionChecker: permissionChecker,
		auditLogger:       auditLogger,
		featureFlags:      featureFlags,
		cache:             cache,
		metrics:           metrics,
	}
}

// Create{{.DomainTitle}} with permission checks, audit logging, and metrics
func (s *ServiceDecorator) Create{{.DomainTitle}}(ctx context.Context, cmd Create{{.DomainTitle}}Command) (*domain.{{.DomainTitle}}, error) {
	start := time.Now()
	
	// Feature flag check
	if !s.featureFlags.IsEnabled(ctx, "{{.DomainLower}}_create") {
		s.metrics.IncrementCounter("{{.DomainLower}}_create_blocked", map[string]string{
			"reason": "feature_disabled",
		})
		return nil, fmt.Errorf("{{.DomainLower}} creation is currently disabled")
	}

	// Permission check
	if err := s.permissionChecker.CheckPermission(ctx, cmd.CreatedBy, "{{.DomainLower}}", "create"); err != nil {
		s.metrics.IncrementCounter("{{.DomainLower}}_create_denied", map[string]string{
			"reason": "permission_denied",
		})
		return nil, fmt.Errorf("permission denied: %w", err)
	}

	// Execute operation
	result, err := s.base.Create{{.DomainTitle}}(ctx, cmd)
	
	// Record metrics
	duration := time.Since(start)
	s.metrics.RecordDuration("{{.DomainLower}}_create_duration", duration, map[string]string{
		"success": fmt.Sprintf("%t", err == nil),
	})
	
	if err != nil {
		s.metrics.IncrementCounter("{{.DomainLower}}_create_error", map[string]string{
			"error": err.Error(),
		})
		return nil, err
	}

	// Audit log
	s.auditLogger.LogCreate(ctx, cmd.CreatedBy, "{{.DomainLower}}", result.ID, result)
	
	// Invalidate list cache
	_ = s.cache.DeleteByPrefix(ctx, "{{.DomainLower}}_list:")
	
	s.metrics.IncrementCounter("{{.DomainLower}}_create_success", nil)
	
	return result, nil
}

// Get{{.DomainTitle}} with caching, permission checks, and audit logging
func (s *ServiceDecorator) Get{{.DomainTitle}}(ctx context.Context, id int) (*domain.{{.DomainTitle}}, error) {
	start := time.Now()
	
	// Try cache first
	cacheKey := fmt.Sprintf("{{.DomainLower}}:%d", id)
	var cached domain.{{.DomainTitle}}
	if err := s.cache.Get(ctx, cacheKey, &cached); err == nil {
		s.metrics.IncrementCounter("{{.DomainLower}}_get_cache_hit", nil)
		return &cached, nil
	}
	s.metrics.IncrementCounter("{{.DomainLower}}_get_cache_miss", nil)

	// Get user from context for audit logging
	userID := auth.GetUserIDFromContext(ctx)
	
	// Permission check (optional for read operations)
	if s.permissionChecker != nil {
		if err := s.permissionChecker.CheckPermission(ctx, userID, "{{.DomainLower}}", "read"); err != nil {
			s.metrics.IncrementCounter("{{.DomainLower}}_get_denied", nil)
			return nil, fmt.Errorf("permission denied: %w", err)
		}
	}

	// Execute operation
	result, err := s.base.Get{{.DomainTitle}}(ctx, id)
	
	// Record metrics
	duration := time.Since(start)
	s.metrics.RecordDuration("{{.DomainLower}}_get_duration", duration, map[string]string{
		"success": fmt.Sprintf("%t", err == nil),
	})
	
	if err != nil {
		s.metrics.IncrementCounter("{{.DomainLower}}_get_error", map[string]string{
			"error": err.Error(),
		})
		return nil, err
	}

	// Audit log access
	if s.auditLogger != nil {
		s.auditLogger.LogAccess(ctx, userID, "{{.DomainLower}}", id)
	}
	
	// Cache the result
	_ = s.cache.Set(ctx, cacheKey, result, 5*time.Minute)
	
	s.metrics.IncrementCounter("{{.DomainLower}}_get_success", nil)
	
	return result, nil
}

// Update{{.DomainTitle}} with permission checks, audit logging, and cache invalidation
func (s *ServiceDecorator) Update{{.DomainTitle}}(ctx context.Context, id int, cmd Update{{.DomainTitle}}Command) (*domain.{{.DomainTitle}}, error) {
	start := time.Now()
	
	// Feature flag check
	if !s.featureFlags.IsEnabled(ctx, "{{.DomainLower}}_update") {
		s.metrics.IncrementCounter("{{.DomainLower}}_update_blocked", map[string]string{
			"reason": "feature_disabled",
		})
		return nil, fmt.Errorf("{{.DomainLower}} update is currently disabled")
	}

	// Permission check
	if err := s.permissionChecker.CheckPermission(ctx, cmd.UpdatedBy, "{{.DomainLower}}", "update"); err != nil {
		s.metrics.IncrementCounter("{{.DomainLower}}_update_denied", nil)
		return nil, fmt.Errorf("permission denied: %w", err)
	}

	// Get current state for audit log
	before, err := s.base.Get{{.DomainTitle}}(ctx, id)
	if err != nil {
		return nil, err
	}

	// Execute operation
	result, err := s.base.Update{{.DomainTitle}}(ctx, id, cmd)
	
	// Record metrics
	duration := time.Since(start)
	s.metrics.RecordDuration("{{.DomainLower}}_update_duration", duration, map[string]string{
		"success": fmt.Sprintf("%t", err == nil),
	})
	
	if err != nil {
		s.metrics.IncrementCounter("{{.DomainLower}}_update_error", map[string]string{
			"error": err.Error(),
		})
		return nil, err
	}

	// Audit log
	s.auditLogger.LogUpdate(ctx, cmd.UpdatedBy, "{{.DomainLower}}", id, before, result)
	
	// Invalidate caches
	_ = s.cache.Delete(ctx, fmt.Sprintf("{{.DomainLower}}:%d", id))
	_ = s.cache.DeleteByPrefix(ctx, "{{.DomainLower}}_list:")
	
	s.metrics.IncrementCounter("{{.DomainLower}}_update_success", nil)
	
	return result, nil
}

// Delete{{.DomainTitle}} with permission checks, audit logging, and cache invalidation
func (s *ServiceDecorator) Delete{{.DomainTitle}}(ctx context.Context, id int) error {
	start := time.Now()
	
	// Feature flag check
	if !s.featureFlags.IsEnabled(ctx, "{{.DomainLower}}_delete") {
		s.metrics.IncrementCounter("{{.DomainLower}}_delete_blocked", map[string]string{
			"reason": "feature_disabled",
		})
		return fmt.Errorf("{{.DomainLower}} deletion is currently disabled")
	}

	// Get user from context
	userID := auth.GetUserIDFromContext(ctx)
	
	// Permission check
	if err := s.permissionChecker.CheckPermission(ctx, userID, "{{.DomainLower}}", "delete"); err != nil {
		s.metrics.IncrementCounter("{{.DomainLower}}_delete_denied", nil)
		return fmt.Errorf("permission denied: %w", err)
	}

	// Execute operation
	err := s.base.Delete{{.DomainTitle}}(ctx, id)
	
	// Record metrics
	duration := time.Since(start)
	s.metrics.RecordDuration("{{.DomainLower}}_delete_duration", duration, map[string]string{
		"success": fmt.Sprintf("%t", err == nil),
	})
	
	if err != nil {
		s.metrics.IncrementCounter("{{.DomainLower}}_delete_error", map[string]string{
			"error": err.Error(),
		})
		return err
	}

	// Audit log
	s.auditLogger.LogDelete(ctx, userID, "{{.DomainLower}}", id)
	
	// Invalidate caches
	_ = s.cache.Delete(ctx, fmt.Sprintf("{{.DomainLower}}:%d", id))
	_ = s.cache.DeleteByPrefix(ctx, "{{.DomainLower}}_list:")
	
	s.metrics.IncrementCounter("{{.DomainLower}}_delete_success", nil)
	
	return nil
}

// List{{.DomainTitle}}s with caching and metrics
func (s *ServiceDecorator) List{{.DomainTitle}}s(ctx context.Context, filters domain.ListFilters) ([]*domain.{{.DomainTitle}}, int, error) {
	start := time.Now()
	
	// Try cache for common queries
	cacheKey := fmt.Sprintf("{{.DomainLower}}_list:%d:%d", filters.Page, filters.PageSize)
	var cachedResult struct {
		Items []*domain.{{.DomainTitle}}
		Total int
	}
	if err := s.cache.Get(ctx, cacheKey, &cachedResult); err == nil {
		s.metrics.IncrementCounter("{{.DomainLower}}_list_cache_hit", nil)
		return cachedResult.Items, cachedResult.Total, nil
	}
	s.metrics.IncrementCounter("{{.DomainLower}}_list_cache_miss", nil)

	// Permission check (optional for list operations)
	userID := auth.GetUserIDFromContext(ctx)
	if s.permissionChecker != nil {
		if err := s.permissionChecker.CheckPermission(ctx, userID, "{{.DomainLower}}", "list"); err != nil {
			s.metrics.IncrementCounter("{{.DomainLower}}_list_denied", nil)
			return nil, 0, fmt.Errorf("permission denied: %w", err)
		}
	}

	// Execute operation
	items, total, err := s.base.List{{.DomainTitle}}s(ctx, filters)
	
	// Record metrics
	duration := time.Since(start)
	s.metrics.RecordDuration("{{.DomainLower}}_list_duration", duration, map[string]string{
		"success": fmt.Sprintf("%t", err == nil),
	})
	s.metrics.RecordGauge("{{.DomainLower}}_total_count", float64(total), nil)
	
	if err != nil {
		s.metrics.IncrementCounter("{{.DomainLower}}_list_error", map[string]string{
			"error": err.Error(),
		})
		return nil, 0, err
	}

	// Cache the result
	cachedResult = struct {
		Items []*domain.{{.DomainTitle}}
		Total int
	}{Items: items, Total: total}
	_ = s.cache.Set(ctx, cacheKey, cachedResult, 2*time.Minute)
	
	s.metrics.IncrementCounter("{{.DomainLower}}_list_success", nil)
	
	return items, total, nil
}

// NoOpPermissionChecker allows all operations (for development/testing)
type NoOpPermissionChecker struct{}

func (n *NoOpPermissionChecker) CheckPermission(ctx context.Context, userID int, resource string, action string) error {
	return nil
}

// NoOpAuditLogger does nothing (for development/testing)
type NoOpAuditLogger struct{}

func (n *NoOpAuditLogger) LogCreate(ctx context.Context, userID int, resource string, resourceID int, data interface{})                {}
func (n *NoOpAuditLogger) LogUpdate(ctx context.Context, userID int, resource string, resourceID int, before, after interface{})       {}
func (n *NoOpAuditLogger) LogDelete(ctx context.Context, userID int, resource string, resourceID int)                                  {}
func (n *NoOpAuditLogger) LogAccess(ctx context.Context, userID int, resource string, resourceID int)                                  {}

// NoOpCacheStore does nothing (for development/testing)
type NoOpCacheStore struct{}

func (n *NoOpCacheStore) Get(ctx context.Context, key string, dest interface{}) error                  { return fmt.Errorf("not found") }
func (n *NoOpCacheStore) Set(ctx context.Context, key string, value interface{}, ttl time.Duration) error { return nil }
func (n *NoOpCacheStore) Delete(ctx context.Context, key string) error                                 { return nil }
func (n *NoOpCacheStore) DeleteByPrefix(ctx context.Context, prefix string) error                      { return nil }

// NoOpMetricsCollector does nothing (for development/testing)
type NoOpMetricsCollector struct{}

func (n *NoOpMetricsCollector) IncrementCounter(metric string, labels map[string]string)                          {}
func (n *NoOpMetricsCollector) RecordDuration(metric string, duration time.Duration, labels map[string]string)   {}
func (n *NoOpMetricsCollector) RecordGauge(metric string, value float64, labels map[string]string)               {}
