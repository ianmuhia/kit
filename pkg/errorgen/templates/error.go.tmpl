// package {{.Package}}
// Code generated by errorgen; DO NOT EDIT.
package {{.Package}}

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"strings"
	"time"
)

// Error represents both user and developer errors with enhanced capabilities
type Error struct {
	Code       string
	Message    string
	HTTPStatus int
	Severity   string
	parameters []string
	timestamp  time.Time
	context    map[string]any
	cause      error
}

// ErrorContext holds contextual information for error propagation
type ErrorContext struct {
	UserID      string
	RequestID   string
	Operation   string
	Component   string
	Additional  map[string]any
}

func (e *Error) Error() string {
	if e.cause != nil {
		return fmt.Sprintf("%s: %s: %v", e.Code, e.Message, e.cause)
	}
	return fmt.Sprintf("%s: %s", e.Code, e.Message)
}

// Unwrap returns the underlying error for errors.Is/As support
func (e *Error) Unwrap() error {
	return e.cause
}

// Wrap wraps an error with this error type
func (e *Error) Wrap(err error) *Error {
	newErr := *e
	newErr.cause = err
	newErr.timestamp = time.Now()
	return &newErr
}

func (e *Error) Format(params ...string) string {
	if len(params) != len(e.parameters) {
		return e.Message
	}
	msg := e.Message
	for i, param := range e.parameters {
		msg = strings.ReplaceAll(msg, "{"+param+"}", params[i])
	}
	return msg
}

// WithContext adds contextual information to the error
func (e *Error) WithContext(ctx context.Context, errCtx *ErrorContext) *Error {
	newErr := *e
	newErr.context = make(map[string]any)

	if errCtx != nil {
		if errCtx.UserID != "" {
			newErr.context["user_id"] = errCtx.UserID
		}
		if errCtx.RequestID != "" {
			newErr.context["request_id"] = errCtx.RequestID
		}
		if errCtx.Operation != "" {
			newErr.context["operation"] = errCtx.Operation
		}
		if errCtx.Component != "" {
			newErr.context["component"] = errCtx.Component
		}
		for k, v := range errCtx.Additional {
			newErr.context[k] = v
		}
	}

	newErr.timestamp = time.Now()
	return &newErr
}


// ToMap converts error to map for serialization
func (e *Error) ToMap() map[string]any{
	result := map[string]any{
		"code":        e.Code,
		"message":     e.Message,
		"http_status": e.HTTPStatus,
		"severity":    e.Severity,
		"timestamp":   e.timestamp,
	}

	if len(e.context) > 0 {
		result["context"] = e.context
	}
	
	return result
}

// WriteJSONResponse writes the error as a JSON response with appropriate HTTP status
func (e *Error) WriteJSONResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	statusCode := e.HTTPStatus
	if statusCode == 0 {
		statusCode = http.StatusInternalServerError
	}
	w.WriteHeader(statusCode)
	return json.NewEncoder(w).Encode(e.ToMap())
}

// Error code constants
const (
	{{range .Errors}}
	{{.Name | codeConstName}} = "{{.Code}}"
	{{end}}
)

// Error definitions
{{range .Errors}}
// {{.Name}} represents the {{.Description | default .Message}}
var {{.Name}} = &Error{
	Code:       {{.Name | codeConstName}},
	Message:    "{{.Message}}",
	HTTPStatus: {{.HTTPStatus | default 0}},
	Severity:   "{{.Severity}}",
	parameters: []string{ {{range .Parameters}}"{{.}}", {{end}} },
}

// New{{.Name}} creates a new {{.Name}} with context and parameters
func New{{.Name}}(ctx context.Context, errCtx *ErrorContext{{if .Parameters}}{{range .Parameters}}, {{. | paramName}} string{{end}}{{end}}) *Error {
	err := {{.Name}}.WithContext(ctx, errCtx){{if .Parameters}}
	err.Message = err.Format({{range $i, $param := .Parameters}}{{if $i}}, {{end}}{{$param | paramName}}{{end}}){{end}}
	return err
}

// Wrap{{.Name}} wraps an error with {{.Name}} context
func Wrap{{.Name}}(err error{{if .Parameters}}{{range .Parameters}}, {{. | paramName}} string{{end}}{{end}}) *Error {
	{{- if .Parameters}}
	newErr := {{.Name}}.Wrap(err)
	newErr.Message = newErr.Format({{range $i, $param := .Parameters}}{{if $i}}, {{end}}{{$param | paramName}}{{end}})
	return newErr
	{{- else}}
	return {{.Name}}.Wrap(err)
	{{- end}}
}

{{end}}
