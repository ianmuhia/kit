package authzgen

const codeTemplate = `// Code generated by authzed-codegen. DO NOT EDIT.
package {{.Package}}

import (
	"context"
	"fmt"
	"sync"

	v1 "github.com/authzed/authzed-go/proto/authzed/api/v1"
	"github.com/authzed/grpcutil"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
	"github.com/authzed/authzed-go/v1"
	"google.golang.org/grpc"
)

// Base types
type Type string
type Relation string
type Permission string
type ID string

// Client wrapper with singleton pattern
type Client struct {
	*authzed.ClientWithExperimental
}

var (
	clientInstance *Client
	clientOnce     sync.Once
	clientErr      error
	clientConfig   *clientOptions
)

// clientOptions holds the configuration for the AuthZed client
type clientOptions struct {
	endpoint string
	token    string
	port     string
	insecure bool
}

// ClientOption is a functional option for configuring the AuthZed client
type ClientOption func(*clientOptions)

// WithEndpoint sets the AuthZed endpoint
func WithEndpoint(endpoint string) ClientOption {
	return func(o *clientOptions) {
		o.endpoint = endpoint
	}
}

// WithPort sets the AuthZed port
func WithPort(port string) ClientOption {
	return func(o *clientOptions) {
		o.port = port
	}
}

// WithToken sets the AuthZed authentication token
func WithToken(token string) ClientOption {
	return func(o *clientOptions) {
		o.token = token
	}
}

// WithInsecure enables insecure connection (for development only)
func WithInsecure(insecure bool) ClientOption {
	return func(o *clientOptions) {
		o.insecure = insecure
	}
}

// SetupClient configures the global client with the provided options
func SetupClient(opts ...ClientOption) {
	config := &clientOptions{
		port:     "50051",
		insecure: true,
	}
	
	for _, opt := range opts {
		opt(config)
	}
	
	clientConfig = config
}

// GetClient returns a singleton AuthZed client instance using the global config
func GetClient() (*Client, error) {
	if clientConfig == nil {
		return nil, fmt.Errorf("client not configured - call SetupClient first")
	}
	
	if clientConfig.endpoint == "" || clientConfig.token == "" {
		return nil, fmt.Errorf("endpoint and token are required - use WithEndpoint() and WithToken()")
	}

	clientOnce.Do(func() {
		client, err := newClient(clientConfig)
		if err != nil {
			clientErr = err
			return
		}
		clientInstance = client
	})
	return clientInstance, clientErr
}

// NewClient creates a new client instance with the provided options (not singleton)
func NewClient(opts ...ClientOption) (*Client, error) {
	config := &clientOptions{
		port:     "50051",
		insecure: true,
	}
	
	for _, opt := range opts {
		opt(config)
	}
	
	if config.endpoint == "" || config.token == "" {
		return nil, fmt.Errorf("endpoint and token are required")
	}
	
	return newClient(config)
}

// newClient is the internal client constructor
func newClient(config *clientOptions) (*Client, error) {
	var dialOpts []grpc.DialOption
	
	if config.insecure {
		dialOpts = append(dialOpts, grpc.WithTransportCredentials(insecure.NewCredentials()))
	}
	
	dialOpts = append(dialOpts, grpcutil.WithInsecureBearerToken(config.token))
	
	client, err := authzed.NewClientWithExperimentalAPIs(
		fmt.Sprintf("%s:%s", config.endpoint, config.port),
		dialOpts...,
	)
	if err != nil {
		return nil, err
	}
	return &Client{client}, nil
}

{{range .Definitions}}
{{$def := .}}
// {{.Name}} definition
const Type{{.Name | camelcase}} Type = "{{.Name}}"

type Relation{{.Name | camelcase}} string
type Permission{{.Name | camelcase}} string

{{range .Relations}}
const {{$def.Name | camelcase}}{{.Name | camelcase}}Rel Relation{{$def.Name | camelcase}} = "{{.Name}}"
{{end}}

{{range .Permissions}}
const {{$def.Name | camelcase}}{{.Name | camelcase}}Perm Permission{{$def.Name | camelcase}} = "{{.Name}}"
{{end}}

// {{.Name | camelcase}} represents a {{.Name}} resource
type {{.Name | camelcase}} string

func New{{.Name | camelcase}}(id string) {{.Name | camelcase}} {
	return {{.Name | camelcase}}(id)
}

func (r {{.Name | camelcase}}) String() string {
	return string(r)
}

func (r {{.Name | camelcase}}) ResourceReference() *v1.ObjectReference {
	return &v1.ObjectReference{
		ObjectType: string(Type{{.Name | camelcase}}),
		ObjectId:   string(r),
	}
}

{{range .Relations}}
{{$rel := .}}
{{$relName := .Name | camelcase}}
{{$defName := $def.Name | camelcase}}
{{$types := .Types}}
// {{.Name | camelcase}} relation methods for {{$def.Name}}

// {{$defName}}{{$relName}}Objects represents the objects that can be related via {{.Name}}
type {{$defName}}{{$relName}}Objects struct {
{{range $types}}
	{{. | extractType | camelcase}} []{{. | extractType | camelcase}} ` + "`json:\"{{. | extractType}},omitempty\"`" + `
{{end}}
}

// Create{{$relName}}Relations creates the {{$rel.Name}} relations for this {{$def.Name}}
// Uses the singleton client from GetClient()
func (r {{$defName}}) Create{{$relName}}Relations(ctx context.Context, objects {{$defName}}{{$relName}}Objects) error {
	client, err := GetClient()
	if err != nil {
		return fmt.Errorf("failed to get client: %w", err)
	}
	var updates []*v1.RelationshipUpdate

{{range $types}}
	for _, obj := range objects.{{. | extractType | camelcase}} {
		updates = append(updates, &v1.RelationshipUpdate{
			Operation: v1.RelationshipUpdate_OPERATION_CREATE,
			Relationship: &v1.Relationship{
				Resource: r.ResourceReference(),
				Relation: string({{$defName}}{{$relName}}Rel),
				Subject: &v1.SubjectReference{
					Object: obj.ResourceReference(),
				},
			},
		})
	}
{{end}}

	if len(updates) == 0 {
		return nil
	}

	_, err = client.WriteRelationships(ctx, &v1.WriteRelationshipsRequest{
		Updates: updates,
	})
	return err
}

// Delete{{$relName}}Relations deletes the {{$rel.Name}} relations for this {{$def.Name}}
// Uses the singleton client from GetClient()
func (r {{$defName}}) Delete{{$relName}}Relations(ctx context.Context, objects {{$defName}}{{$relName}}Objects) error {
	client, err := GetClient()
	if err != nil {
		return fmt.Errorf("failed to get client: %w", err)
	}
	var updates []*v1.RelationshipUpdate

{{range $types}}
	for _, obj := range objects.{{. | extractType | camelcase}} {
		updates = append(updates, &v1.RelationshipUpdate{
			Operation: v1.RelationshipUpdate_OPERATION_DELETE,
			Relationship: &v1.Relationship{
				Resource: r.ResourceReference(),
				Relation: string({{$defName}}{{$relName}}Rel),
				Subject: &v1.SubjectReference{
					Object: obj.ResourceReference(),
				},
			},
		})
	}
{{end}}

	if len(updates) == 0 {
		return nil
	}

	_, writeErr := client.WriteRelationships(ctx, &v1.WriteRelationshipsRequest{
		Updates: updates,
	})
	return writeErr
}

// Read{{$relName}}Relations reads the {{$rel.Name}} relations for this {{$def.Name}}
// Uses the singleton client from GetClient()
func (r {{$defName}}) Read{{$relName}}Relations(ctx context.Context) ({{$defName}}{{$relName}}Objects, error) {
	client, err := GetClient()
	if err != nil {
		return {{$defName}}{{$relName}}Objects{}, fmt.Errorf("failed to get client: %w", err)
	}
	var result {{$defName}}{{$relName}}Objects

	stream, err := client.ReadRelationships(ctx, &v1.ReadRelationshipsRequest{
		Consistency: &v1.Consistency{
			Requirement: &v1.Consistency_FullyConsistent{
				FullyConsistent: true,
			},
		},
		RelationshipFilter: &v1.RelationshipFilter{
			ResourceType:       string(Type{{$defName}}),
			OptionalResourceId: string(r),
			OptionalRelation:   string({{$defName}}{{$relName}}Rel),
		},
	})
	if err != nil {
		return result, err
	}

	for {
		resp, err := stream.Recv()
		if err != nil {
			if err.Error() == "EOF" {
				break
			}
			return result, err
		}

		subject := resp.Relationship.Subject.Object
		switch subject.ObjectType {
{{range $types}}
		case string(Type{{. | extractType | camelcase}}):
			result.{{. | extractType | camelcase}} = append(result.{{. | extractType | camelcase}}, {{. | extractType | camelcase}}(subject.ObjectId))
{{end}}
		}
	}

	return result, nil
}

{{end}}

{{range .Permissions}}
{{$perm := .}}
{{$permName := .Name | camelcase}}
{{$defName := $def.Name | camelcase}}
// {{.Name | camelcase}} permission methods for {{$def.Name}}

// Check{{$defName}}{{$permName}}Inputs represents the subjects that can be checked for {{.Name}} permission
type Check{{$defName}}{{$permName}}Inputs struct {
	User []User ` + "`json:\"user,omitempty\"`" + `
}

// Check{{$permName}} checks if any of the provided subjects have {{$perm.Name}} permission on this {{$def.Name}}
// Uses the singleton client from GetClient()
func (r {{$defName}}) Check{{$permName}}(ctx context.Context, inputs Check{{$defName}}{{$permName}}Inputs) (bool, error) {
	client, err := GetClient()
	if err != nil {
		return false, fmt.Errorf("failed to get client: %w", err)
	}

	for _, subject := range inputs.User {
		resp, err := client.CheckPermission(ctx, &v1.CheckPermissionRequest{
			Resource: r.ResourceReference(),
			Permission: string({{$defName}}{{$permName}}Perm),
			Subject: &v1.SubjectReference{
				Object: subject.ResourceReference(),
			},
		})
		if err != nil {
			return false, err
		}
		if resp.Permissionship != v1.CheckPermissionResponse_PERMISSIONSHIP_HAS_PERMISSION {
			return false, nil
		}
	}
	return true, nil
}

// Lookup{{$permName}}Subjects looks up subjects that have {{$perm.Name}} permission on this {{$def.Name}}
// Uses the singleton client from GetClient()
func (r {{$defName}}) Lookup{{$permName}}Subjects(ctx context.Context, subjectType string) ([]string, error) {
	client, err := GetClient()
	if err != nil {
		return nil, fmt.Errorf("failed to get client: %w", err)
	}
	var subjects []string

	stream, err := client.LookupSubjects(ctx, &v1.LookupSubjectsRequest{
		Consistency: &v1.Consistency{
			Requirement: &v1.Consistency_FullyConsistent{
				FullyConsistent: true,
			},
		},
		Resource: r.ResourceReference(),
		Permission: string({{$defName}}{{$permName}}Perm),
		SubjectObjectType: subjectType,
	})
	if err != nil {
		return nil, err
	}

	for {
		lookupResp, err := stream.Recv()
		if err != nil {
			if err.Error() == "EOF" {
				break
			}
			return nil, err
		}

		subjects = append(subjects, lookupResp.Subject.SubjectObjectId)
	}

	return subjects, nil
}

// Lookup{{$permName}}Resources looks up all {{$def.Name}} resources where the specified subject has {{$perm.Name}} permission
// Uses the singleton client from GetClient()
func Lookup{{$defName}}{{$permName}}Resources(ctx context.Context, subject *v1.SubjectReference) ([]{{$defName}}, error) {
	client, err := GetClient()
	if err != nil {
		return nil, fmt.Errorf("failed to get client: %w", err)
	}
	var resources []{{$defName}}

	stream, err := client.LookupResources(ctx, &v1.LookupResourcesRequest{
		Consistency: &v1.Consistency{
			Requirement: &v1.Consistency_FullyConsistent{
				FullyConsistent: true,
			},
		},
		ResourceObjectType: string(Type{{$defName}}),
		Permission: string({{$defName}}{{$permName}}Perm),
		Subject: subject,
	})
	if err != nil {
		return nil, err
	}

	for {
		lookupResp, err := stream.Recv()
		if err != nil {
			if err.Error() == "EOF" {
				break
			}
			return nil, err
		}

		resources = append(resources, {{$defName}}(lookupResp.ResourceObjectId))
	}

	return resources, nil
}

// Lookup{{$permName}}ResourcesForUser is a convenience method for looking up {{$def.Name}} resources where a user has {{$perm.Name}} permission
// Uses the singleton client from GetClient()
func Lookup{{$defName}}{{$permName}}ResourcesForUser(ctx context.Context, user User) ([]{{$defName}}, error) {
	return Lookup{{$defName}}{{$permName}}Resources(ctx, &v1.SubjectReference{
		Object: user.ResourceReference(),
	})
}

{{end}}

{{end}}`
